// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"

	pb "github.com/hyperledger/fabric-protos-go/peer"
	"github.com/hyperledger/fabric-sdk-go/pkg/client/channel"
	"github.com/hyperledger/fabric-sdk-go/pkg/common/providers/fab"
	"github.com/trustbloc/fabric-peer-ext/pkg/txn/api"
)

type TxnService struct {
	EndorseStub        func(req *api.Request) (resp *channel.Response, err error)
	endorseMutex       sync.RWMutex
	endorseArgsForCall []struct {
		req *api.Request
	}
	endorseReturns struct {
		result1 *channel.Response
		result2 error
	}
	endorseReturnsOnCall map[int]struct {
		result1 *channel.Response
		result2 error
	}
	EndorseAndCommitStub        func(req *api.Request) (resp *channel.Response, committed bool, err error)
	endorseAndCommitMutex       sync.RWMutex
	endorseAndCommitArgsForCall []struct {
		req *api.Request
	}
	endorseAndCommitReturns struct {
		result1 *channel.Response
		result2 bool
		result3 error
	}
	endorseAndCommitReturnsOnCall map[int]struct {
		result1 *channel.Response
		result2 bool
		result3 error
	}
	CommitEndorsementsStub        func(req *api.CommitRequest) (*channel.Response, bool, error)
	commitEndorsementsMutex       sync.RWMutex
	commitEndorsementsArgsForCall []struct {
		req *api.CommitRequest
	}
	commitEndorsementsReturns struct {
		result1 *channel.Response
		result2 bool
		result3 error
	}
	commitEndorsementsReturnsOnCall map[int]struct {
		result1 *channel.Response
		result2 bool
		result3 error
	}
	SigningIdentityStub        func() ([]byte, error)
	signingIdentityMutex       sync.RWMutex
	signingIdentityArgsForCall []struct{}
	signingIdentityReturns     struct {
		result1 []byte
		result2 error
	}
	signingIdentityReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	GetPeerStub        func(endpoint string) (fab.Peer, error)
	getPeerMutex       sync.RWMutex
	getPeerArgsForCall []struct {
		endpoint string
	}
	getPeerReturns struct {
		result1 fab.Peer
		result2 error
	}
	getPeerReturnsOnCall map[int]struct {
		result1 fab.Peer
		result2 error
	}
	VerifyProposalSignatureStub        func(signedProposal *pb.SignedProposal) error
	verifyProposalSignatureMutex       sync.RWMutex
	verifyProposalSignatureArgsForCall []struct {
		signedProposal *pb.SignedProposal
	}
	verifyProposalSignatureReturns struct {
		result1 error
	}
	verifyProposalSignatureReturnsOnCall map[int]struct {
		result1 error
	}
	ValidateProposalResponsesStub        func(signedProposal *pb.SignedProposal, proposalResponses []*pb.ProposalResponse) (pb.TxValidationCode, error)
	validateProposalResponsesMutex       sync.RWMutex
	validateProposalResponsesArgsForCall []struct {
		signedProposal    *pb.SignedProposal
		proposalResponses []*pb.ProposalResponse
	}
	validateProposalResponsesReturns struct {
		result1 pb.TxValidationCode
		result2 error
	}
	validateProposalResponsesReturnsOnCall map[int]struct {
		result1 pb.TxValidationCode
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *TxnService) Endorse(req *api.Request) (resp *channel.Response, err error) {
	fake.endorseMutex.Lock()
	ret, specificReturn := fake.endorseReturnsOnCall[len(fake.endorseArgsForCall)]
	fake.endorseArgsForCall = append(fake.endorseArgsForCall, struct {
		req *api.Request
	}{req})
	fake.recordInvocation("Endorse", []interface{}{req})
	fake.endorseMutex.Unlock()
	if fake.EndorseStub != nil {
		return fake.EndorseStub(req)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.endorseReturns.result1, fake.endorseReturns.result2
}

func (fake *TxnService) EndorseCallCount() int {
	fake.endorseMutex.RLock()
	defer fake.endorseMutex.RUnlock()
	return len(fake.endorseArgsForCall)
}

func (fake *TxnService) EndorseArgsForCall(i int) *api.Request {
	fake.endorseMutex.RLock()
	defer fake.endorseMutex.RUnlock()
	return fake.endorseArgsForCall[i].req
}

func (fake *TxnService) EndorseReturns(result1 *channel.Response, result2 error) {
	fake.EndorseStub = nil
	fake.endorseReturns = struct {
		result1 *channel.Response
		result2 error
	}{result1, result2}
}

func (fake *TxnService) EndorseReturnsOnCall(i int, result1 *channel.Response, result2 error) {
	fake.EndorseStub = nil
	if fake.endorseReturnsOnCall == nil {
		fake.endorseReturnsOnCall = make(map[int]struct {
			result1 *channel.Response
			result2 error
		})
	}
	fake.endorseReturnsOnCall[i] = struct {
		result1 *channel.Response
		result2 error
	}{result1, result2}
}

func (fake *TxnService) EndorseAndCommit(req *api.Request) (resp *channel.Response, committed bool, err error) {
	fake.endorseAndCommitMutex.Lock()
	ret, specificReturn := fake.endorseAndCommitReturnsOnCall[len(fake.endorseAndCommitArgsForCall)]
	fake.endorseAndCommitArgsForCall = append(fake.endorseAndCommitArgsForCall, struct {
		req *api.Request
	}{req})
	fake.recordInvocation("EndorseAndCommit", []interface{}{req})
	fake.endorseAndCommitMutex.Unlock()
	if fake.EndorseAndCommitStub != nil {
		return fake.EndorseAndCommitStub(req)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.endorseAndCommitReturns.result1, fake.endorseAndCommitReturns.result2, fake.endorseAndCommitReturns.result3
}

func (fake *TxnService) EndorseAndCommitCallCount() int {
	fake.endorseAndCommitMutex.RLock()
	defer fake.endorseAndCommitMutex.RUnlock()
	return len(fake.endorseAndCommitArgsForCall)
}

func (fake *TxnService) EndorseAndCommitArgsForCall(i int) *api.Request {
	fake.endorseAndCommitMutex.RLock()
	defer fake.endorseAndCommitMutex.RUnlock()
	return fake.endorseAndCommitArgsForCall[i].req
}

func (fake *TxnService) EndorseAndCommitReturns(result1 *channel.Response, result2 bool, result3 error) {
	fake.EndorseAndCommitStub = nil
	fake.endorseAndCommitReturns = struct {
		result1 *channel.Response
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *TxnService) EndorseAndCommitReturnsOnCall(i int, result1 *channel.Response, result2 bool, result3 error) {
	fake.EndorseAndCommitStub = nil
	if fake.endorseAndCommitReturnsOnCall == nil {
		fake.endorseAndCommitReturnsOnCall = make(map[int]struct {
			result1 *channel.Response
			result2 bool
			result3 error
		})
	}
	fake.endorseAndCommitReturnsOnCall[i] = struct {
		result1 *channel.Response
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *TxnService) CommitEndorsements(req *api.CommitRequest) (*channel.Response, bool, error) {
	fake.commitEndorsementsMutex.Lock()
	ret, specificReturn := fake.commitEndorsementsReturnsOnCall[len(fake.commitEndorsementsArgsForCall)]
	fake.commitEndorsementsArgsForCall = append(fake.commitEndorsementsArgsForCall, struct {
		req *api.CommitRequest
	}{req})
	fake.recordInvocation("CommitEndorsements", []interface{}{req})
	fake.commitEndorsementsMutex.Unlock()
	if fake.CommitEndorsementsStub != nil {
		return fake.CommitEndorsementsStub(req)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.commitEndorsementsReturns.result1, fake.commitEndorsementsReturns.result2, fake.commitEndorsementsReturns.result3
}

func (fake *TxnService) CommitEndorsementsCallCount() int {
	fake.commitEndorsementsMutex.RLock()
	defer fake.commitEndorsementsMutex.RUnlock()
	return len(fake.commitEndorsementsArgsForCall)
}

func (fake *TxnService) CommitEndorsementsArgsForCall(i int) *api.CommitRequest {
	fake.commitEndorsementsMutex.RLock()
	defer fake.commitEndorsementsMutex.RUnlock()
	return fake.commitEndorsementsArgsForCall[i].req
}

func (fake *TxnService) CommitEndorsementsReturns(result1 *channel.Response, result2 bool, result3 error) {
	fake.CommitEndorsementsStub = nil
	fake.commitEndorsementsReturns = struct {
		result1 *channel.Response
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *TxnService) CommitEndorsementsReturnsOnCall(i int, result1 *channel.Response, result2 bool, result3 error) {
	fake.CommitEndorsementsStub = nil
	if fake.commitEndorsementsReturnsOnCall == nil {
		fake.commitEndorsementsReturnsOnCall = make(map[int]struct {
			result1 *channel.Response
			result2 bool
			result3 error
		})
	}
	fake.commitEndorsementsReturnsOnCall[i] = struct {
		result1 *channel.Response
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *TxnService) SigningIdentity() ([]byte, error) {
	fake.signingIdentityMutex.Lock()
	ret, specificReturn := fake.signingIdentityReturnsOnCall[len(fake.signingIdentityArgsForCall)]
	fake.signingIdentityArgsForCall = append(fake.signingIdentityArgsForCall, struct{}{})
	fake.recordInvocation("SigningIdentity", []interface{}{})
	fake.signingIdentityMutex.Unlock()
	if fake.SigningIdentityStub != nil {
		return fake.SigningIdentityStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.signingIdentityReturns.result1, fake.signingIdentityReturns.result2
}

func (fake *TxnService) SigningIdentityCallCount() int {
	fake.signingIdentityMutex.RLock()
	defer fake.signingIdentityMutex.RUnlock()
	return len(fake.signingIdentityArgsForCall)
}

func (fake *TxnService) SigningIdentityReturns(result1 []byte, result2 error) {
	fake.SigningIdentityStub = nil
	fake.signingIdentityReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *TxnService) SigningIdentityReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.SigningIdentityStub = nil
	if fake.signingIdentityReturnsOnCall == nil {
		fake.signingIdentityReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.signingIdentityReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *TxnService) GetPeer(endpoint string) (fab.Peer, error) {
	fake.getPeerMutex.Lock()
	ret, specificReturn := fake.getPeerReturnsOnCall[len(fake.getPeerArgsForCall)]
	fake.getPeerArgsForCall = append(fake.getPeerArgsForCall, struct {
		endpoint string
	}{endpoint})
	fake.recordInvocation("GetPeer", []interface{}{endpoint})
	fake.getPeerMutex.Unlock()
	if fake.GetPeerStub != nil {
		return fake.GetPeerStub(endpoint)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getPeerReturns.result1, fake.getPeerReturns.result2
}

func (fake *TxnService) GetPeerCallCount() int {
	fake.getPeerMutex.RLock()
	defer fake.getPeerMutex.RUnlock()
	return len(fake.getPeerArgsForCall)
}

func (fake *TxnService) GetPeerArgsForCall(i int) string {
	fake.getPeerMutex.RLock()
	defer fake.getPeerMutex.RUnlock()
	return fake.getPeerArgsForCall[i].endpoint
}

func (fake *TxnService) GetPeerReturns(result1 fab.Peer, result2 error) {
	fake.GetPeerStub = nil
	fake.getPeerReturns = struct {
		result1 fab.Peer
		result2 error
	}{result1, result2}
}

func (fake *TxnService) GetPeerReturnsOnCall(i int, result1 fab.Peer, result2 error) {
	fake.GetPeerStub = nil
	if fake.getPeerReturnsOnCall == nil {
		fake.getPeerReturnsOnCall = make(map[int]struct {
			result1 fab.Peer
			result2 error
		})
	}
	fake.getPeerReturnsOnCall[i] = struct {
		result1 fab.Peer
		result2 error
	}{result1, result2}
}

func (fake *TxnService) VerifyProposalSignature(signedProposal *pb.SignedProposal) error {
	fake.verifyProposalSignatureMutex.Lock()
	ret, specificReturn := fake.verifyProposalSignatureReturnsOnCall[len(fake.verifyProposalSignatureArgsForCall)]
	fake.verifyProposalSignatureArgsForCall = append(fake.verifyProposalSignatureArgsForCall, struct {
		signedProposal *pb.SignedProposal
	}{signedProposal})
	fake.recordInvocation("VerifyProposalSignature", []interface{}{signedProposal})
	fake.verifyProposalSignatureMutex.Unlock()
	if fake.VerifyProposalSignatureStub != nil {
		return fake.VerifyProposalSignatureStub(signedProposal)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.verifyProposalSignatureReturns.result1
}

func (fake *TxnService) VerifyProposalSignatureCallCount() int {
	fake.verifyProposalSignatureMutex.RLock()
	defer fake.verifyProposalSignatureMutex.RUnlock()
	return len(fake.verifyProposalSignatureArgsForCall)
}

func (fake *TxnService) VerifyProposalSignatureArgsForCall(i int) *pb.SignedProposal {
	fake.verifyProposalSignatureMutex.RLock()
	defer fake.verifyProposalSignatureMutex.RUnlock()
	return fake.verifyProposalSignatureArgsForCall[i].signedProposal
}

func (fake *TxnService) VerifyProposalSignatureReturns(result1 error) {
	fake.VerifyProposalSignatureStub = nil
	fake.verifyProposalSignatureReturns = struct {
		result1 error
	}{result1}
}

func (fake *TxnService) VerifyProposalSignatureReturnsOnCall(i int, result1 error) {
	fake.VerifyProposalSignatureStub = nil
	if fake.verifyProposalSignatureReturnsOnCall == nil {
		fake.verifyProposalSignatureReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.verifyProposalSignatureReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *TxnService) ValidateProposalResponses(signedProposal *pb.SignedProposal, proposalResponses []*pb.ProposalResponse) (pb.TxValidationCode, error) {
	var proposalResponsesCopy []*pb.ProposalResponse
	if proposalResponses != nil {
		proposalResponsesCopy = make([]*pb.ProposalResponse, len(proposalResponses))
		copy(proposalResponsesCopy, proposalResponses)
	}
	fake.validateProposalResponsesMutex.Lock()
	ret, specificReturn := fake.validateProposalResponsesReturnsOnCall[len(fake.validateProposalResponsesArgsForCall)]
	fake.validateProposalResponsesArgsForCall = append(fake.validateProposalResponsesArgsForCall, struct {
		signedProposal    *pb.SignedProposal
		proposalResponses []*pb.ProposalResponse
	}{signedProposal, proposalResponsesCopy})
	fake.recordInvocation("ValidateProposalResponses", []interface{}{signedProposal, proposalResponsesCopy})
	fake.validateProposalResponsesMutex.Unlock()
	if fake.ValidateProposalResponsesStub != nil {
		return fake.ValidateProposalResponsesStub(signedProposal, proposalResponses)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.validateProposalResponsesReturns.result1, fake.validateProposalResponsesReturns.result2
}

func (fake *TxnService) ValidateProposalResponsesCallCount() int {
	fake.validateProposalResponsesMutex.RLock()
	defer fake.validateProposalResponsesMutex.RUnlock()
	return len(fake.validateProposalResponsesArgsForCall)
}

func (fake *TxnService) ValidateProposalResponsesArgsForCall(i int) (*pb.SignedProposal, []*pb.ProposalResponse) {
	fake.validateProposalResponsesMutex.RLock()
	defer fake.validateProposalResponsesMutex.RUnlock()
	return fake.validateProposalResponsesArgsForCall[i].signedProposal, fake.validateProposalResponsesArgsForCall[i].proposalResponses
}

func (fake *TxnService) ValidateProposalResponsesReturns(result1 pb.TxValidationCode, result2 error) {
	fake.ValidateProposalResponsesStub = nil
	fake.validateProposalResponsesReturns = struct {
		result1 pb.TxValidationCode
		result2 error
	}{result1, result2}
}

func (fake *TxnService) ValidateProposalResponsesReturnsOnCall(i int, result1 pb.TxValidationCode, result2 error) {
	fake.ValidateProposalResponsesStub = nil
	if fake.validateProposalResponsesReturnsOnCall == nil {
		fake.validateProposalResponsesReturnsOnCall = make(map[int]struct {
			result1 pb.TxValidationCode
			result2 error
		})
	}
	fake.validateProposalResponsesReturnsOnCall[i] = struct {
		result1 pb.TxValidationCode
		result2 error
	}{result1, result2}
}

func (fake *TxnService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.endorseMutex.RLock()
	defer fake.endorseMutex.RUnlock()
	fake.endorseAndCommitMutex.RLock()
	defer fake.endorseAndCommitMutex.RUnlock()
	fake.commitEndorsementsMutex.RLock()
	defer fake.commitEndorsementsMutex.RUnlock()
	fake.signingIdentityMutex.RLock()
	defer fake.signingIdentityMutex.RUnlock()
	fake.getPeerMutex.RLock()
	defer fake.getPeerMutex.RUnlock()
	fake.verifyProposalSignatureMutex.RLock()
	defer fake.verifyProposalSignatureMutex.RUnlock()
	fake.validateProposalResponsesMutex.RLock()
	defer fake.validateProposalResponsesMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *TxnService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ api.Service = new(TxnService)

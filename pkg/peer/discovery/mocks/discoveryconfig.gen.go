// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"
	"time"
)

type DiscoveryConfig struct {
	DiscoveryCacheExpirationTimeStub        func() time.Duration
	discoveryCacheExpirationTimeMutex       sync.RWMutex
	discoveryCacheExpirationTimeArgsForCall []struct{}
	discoveryCacheExpirationTimeReturns     struct {
		result1 time.Duration
	}
	discoveryCacheExpirationTimeReturnsOnCall map[int]struct {
		result1 time.Duration
	}
	DiscoveryGossipMaxAttemptsStub        func() int
	discoveryGossipMaxAttemptsMutex       sync.RWMutex
	discoveryGossipMaxAttemptsArgsForCall []struct{}
	discoveryGossipMaxAttemptsReturns     struct {
		result1 int
	}
	discoveryGossipMaxAttemptsReturnsOnCall map[int]struct {
		result1 int
	}
	DiscoveryGossipTimeoutStub        func() time.Duration
	discoveryGossipTimeoutMutex       sync.RWMutex
	discoveryGossipTimeoutArgsForCall []struct{}
	discoveryGossipTimeoutReturns     struct {
		result1 time.Duration
	}
	discoveryGossipTimeoutReturnsOnCall map[int]struct {
		result1 time.Duration
	}
	DiscoveryGossipMaxPeersStub        func() int
	discoveryGossipMaxPeersMutex       sync.RWMutex
	discoveryGossipMaxPeersArgsForCall []struct{}
	discoveryGossipMaxPeersReturns     struct {
		result1 int
	}
	discoveryGossipMaxPeersReturnsOnCall map[int]struct {
		result1 int
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *DiscoveryConfig) DiscoveryCacheExpirationTime() time.Duration {
	fake.discoveryCacheExpirationTimeMutex.Lock()
	ret, specificReturn := fake.discoveryCacheExpirationTimeReturnsOnCall[len(fake.discoveryCacheExpirationTimeArgsForCall)]
	fake.discoveryCacheExpirationTimeArgsForCall = append(fake.discoveryCacheExpirationTimeArgsForCall, struct{}{})
	fake.recordInvocation("DiscoveryCacheExpirationTime", []interface{}{})
	fake.discoveryCacheExpirationTimeMutex.Unlock()
	if fake.DiscoveryCacheExpirationTimeStub != nil {
		return fake.DiscoveryCacheExpirationTimeStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.discoveryCacheExpirationTimeReturns.result1
}

func (fake *DiscoveryConfig) DiscoveryCacheExpirationTimeCallCount() int {
	fake.discoveryCacheExpirationTimeMutex.RLock()
	defer fake.discoveryCacheExpirationTimeMutex.RUnlock()
	return len(fake.discoveryCacheExpirationTimeArgsForCall)
}

func (fake *DiscoveryConfig) DiscoveryCacheExpirationTimeReturns(result1 time.Duration) {
	fake.DiscoveryCacheExpirationTimeStub = nil
	fake.discoveryCacheExpirationTimeReturns = struct {
		result1 time.Duration
	}{result1}
}

func (fake *DiscoveryConfig) DiscoveryCacheExpirationTimeReturnsOnCall(i int, result1 time.Duration) {
	fake.DiscoveryCacheExpirationTimeStub = nil
	if fake.discoveryCacheExpirationTimeReturnsOnCall == nil {
		fake.discoveryCacheExpirationTimeReturnsOnCall = make(map[int]struct {
			result1 time.Duration
		})
	}
	fake.discoveryCacheExpirationTimeReturnsOnCall[i] = struct {
		result1 time.Duration
	}{result1}
}

func (fake *DiscoveryConfig) DiscoveryGossipMaxAttempts() int {
	fake.discoveryGossipMaxAttemptsMutex.Lock()
	ret, specificReturn := fake.discoveryGossipMaxAttemptsReturnsOnCall[len(fake.discoveryGossipMaxAttemptsArgsForCall)]
	fake.discoveryGossipMaxAttemptsArgsForCall = append(fake.discoveryGossipMaxAttemptsArgsForCall, struct{}{})
	fake.recordInvocation("DiscoveryGossipMaxAttempts", []interface{}{})
	fake.discoveryGossipMaxAttemptsMutex.Unlock()
	if fake.DiscoveryGossipMaxAttemptsStub != nil {
		return fake.DiscoveryGossipMaxAttemptsStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.discoveryGossipMaxAttemptsReturns.result1
}

func (fake *DiscoveryConfig) DiscoveryGossipMaxAttemptsCallCount() int {
	fake.discoveryGossipMaxAttemptsMutex.RLock()
	defer fake.discoveryGossipMaxAttemptsMutex.RUnlock()
	return len(fake.discoveryGossipMaxAttemptsArgsForCall)
}

func (fake *DiscoveryConfig) DiscoveryGossipMaxAttemptsReturns(result1 int) {
	fake.DiscoveryGossipMaxAttemptsStub = nil
	fake.discoveryGossipMaxAttemptsReturns = struct {
		result1 int
	}{result1}
}

func (fake *DiscoveryConfig) DiscoveryGossipMaxAttemptsReturnsOnCall(i int, result1 int) {
	fake.DiscoveryGossipMaxAttemptsStub = nil
	if fake.discoveryGossipMaxAttemptsReturnsOnCall == nil {
		fake.discoveryGossipMaxAttemptsReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.discoveryGossipMaxAttemptsReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *DiscoveryConfig) DiscoveryGossipTimeout() time.Duration {
	fake.discoveryGossipTimeoutMutex.Lock()
	ret, specificReturn := fake.discoveryGossipTimeoutReturnsOnCall[len(fake.discoveryGossipTimeoutArgsForCall)]
	fake.discoveryGossipTimeoutArgsForCall = append(fake.discoveryGossipTimeoutArgsForCall, struct{}{})
	fake.recordInvocation("DiscoveryGossipTimeout", []interface{}{})
	fake.discoveryGossipTimeoutMutex.Unlock()
	if fake.DiscoveryGossipTimeoutStub != nil {
		return fake.DiscoveryGossipTimeoutStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.discoveryGossipTimeoutReturns.result1
}

func (fake *DiscoveryConfig) DiscoveryGossipTimeoutCallCount() int {
	fake.discoveryGossipTimeoutMutex.RLock()
	defer fake.discoveryGossipTimeoutMutex.RUnlock()
	return len(fake.discoveryGossipTimeoutArgsForCall)
}

func (fake *DiscoveryConfig) DiscoveryGossipTimeoutReturns(result1 time.Duration) {
	fake.DiscoveryGossipTimeoutStub = nil
	fake.discoveryGossipTimeoutReturns = struct {
		result1 time.Duration
	}{result1}
}

func (fake *DiscoveryConfig) DiscoveryGossipTimeoutReturnsOnCall(i int, result1 time.Duration) {
	fake.DiscoveryGossipTimeoutStub = nil
	if fake.discoveryGossipTimeoutReturnsOnCall == nil {
		fake.discoveryGossipTimeoutReturnsOnCall = make(map[int]struct {
			result1 time.Duration
		})
	}
	fake.discoveryGossipTimeoutReturnsOnCall[i] = struct {
		result1 time.Duration
	}{result1}
}

func (fake *DiscoveryConfig) DiscoveryGossipMaxPeers() int {
	fake.discoveryGossipMaxPeersMutex.Lock()
	ret, specificReturn := fake.discoveryGossipMaxPeersReturnsOnCall[len(fake.discoveryGossipMaxPeersArgsForCall)]
	fake.discoveryGossipMaxPeersArgsForCall = append(fake.discoveryGossipMaxPeersArgsForCall, struct{}{})
	fake.recordInvocation("DiscoveryGossipMaxPeers", []interface{}{})
	fake.discoveryGossipMaxPeersMutex.Unlock()
	if fake.DiscoveryGossipMaxPeersStub != nil {
		return fake.DiscoveryGossipMaxPeersStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.discoveryGossipMaxPeersReturns.result1
}

func (fake *DiscoveryConfig) DiscoveryGossipMaxPeersCallCount() int {
	fake.discoveryGossipMaxPeersMutex.RLock()
	defer fake.discoveryGossipMaxPeersMutex.RUnlock()
	return len(fake.discoveryGossipMaxPeersArgsForCall)
}

func (fake *DiscoveryConfig) DiscoveryGossipMaxPeersReturns(result1 int) {
	fake.DiscoveryGossipMaxPeersStub = nil
	fake.discoveryGossipMaxPeersReturns = struct {
		result1 int
	}{result1}
}

func (fake *DiscoveryConfig) DiscoveryGossipMaxPeersReturnsOnCall(i int, result1 int) {
	fake.DiscoveryGossipMaxPeersStub = nil
	if fake.discoveryGossipMaxPeersReturnsOnCall == nil {
		fake.discoveryGossipMaxPeersReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.discoveryGossipMaxPeersReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *DiscoveryConfig) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.discoveryCacheExpirationTimeMutex.RLock()
	defer fake.discoveryCacheExpirationTimeMutex.RUnlock()
	fake.discoveryGossipMaxAttemptsMutex.RLock()
	defer fake.discoveryGossipMaxAttemptsMutex.RUnlock()
	fake.discoveryGossipTimeoutMutex.RLock()
	defer fake.discoveryGossipTimeoutMutex.RUnlock()
	fake.discoveryGossipMaxPeersMutex.RLock()
	defer fake.discoveryGossipMaxPeersMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *DiscoveryConfig) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
